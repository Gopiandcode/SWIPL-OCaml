<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Swipl (swipl.Swipl)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">swipl</a> &#x00BB; Swipl</nav><h1>Module <code>Swipl</code></h1></header><dl><dt class="spec value" id="val-initialise"><a href="#val-initialise" class="anchor"></a><code><span class="keyword">val</span> initialise : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>initialise ()</code> initialises the SWI-prolog engine. It must be called at the start of the program before creating any terms.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p><code>t [@@deriving eq, ord, show]</code> represents prolog terms.</p></dd></dl><dl><dt class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span class="keyword">type</span> ty</code> = <code>[ </code><table class="variant"><tr id="type-ty.Atom" class="anchored"><td class="def constructor"><a href="#type-ty.Atom" class="anchor"></a><code>| </code><code>`Atom</code></td></tr><tr id="type-ty.Blob" class="anchored"><td class="def constructor"><a href="#type-ty.Blob" class="anchor"></a><code>| </code><code>`Blob</code></td></tr><tr id="type-ty.Bool" class="anchored"><td class="def constructor"><a href="#type-ty.Bool" class="anchor"></a><code>| </code><code>`Bool</code></td></tr><tr id="type-ty.Dict" class="anchored"><td class="def constructor"><a href="#type-ty.Dict" class="anchor"></a><code>| </code><code>`Dict</code></td></tr><tr id="type-ty.Float" class="anchored"><td class="def constructor"><a href="#type-ty.Float" class="anchor"></a><code>| </code><code>`Float</code></td></tr><tr id="type-ty.Integer" class="anchored"><td class="def constructor"><a href="#type-ty.Integer" class="anchor"></a><code>| </code><code>`Integer</code></td></tr><tr id="type-ty.ListPair" class="anchored"><td class="def constructor"><a href="#type-ty.ListPair" class="anchor"></a><code>| </code><code>`ListPair</code></td></tr><tr id="type-ty.Nil" class="anchored"><td class="def constructor"><a href="#type-ty.Nil" class="anchor"></a><code>| </code><code>`Nil</code></td></tr><tr id="type-ty.Rational" class="anchored"><td class="def constructor"><a href="#type-ty.Rational" class="anchor"></a><code>| </code><code>`Rational</code></td></tr><tr id="type-ty.String" class="anchored"><td class="def constructor"><a href="#type-ty.String" class="anchor"></a><code>| </code><code>`String</code></td></tr><tr id="type-ty.Term" class="anchored"><td class="def constructor"><a href="#type-ty.Term" class="anchor"></a><code>| </code><code>`Term</code></td></tr><tr id="type-ty.Variable" class="anchored"><td class="def constructor"><a href="#type-ty.Variable" class="anchor"></a><code>| </code><code>`Variable</code></td></tr></table><code> ]</code></dt><dd><p>Represents types of prolog terms</p></dd></dl><dl><dt class="spec type" id="type-query"><a href="#type-query" class="anchor"></a><code><span class="keyword">type</span> query</code></dt><dd><p>Represents an in-progress prolog query.</p><p><b>Note</b>: It is an error to run another query before the result of a prior query has been consumed.</p></dd></dl><dl><dt class="spec type" id="type-ctx"><a href="#type-ctx" class="anchor"></a><code><span class="keyword">type</span> ctx</code></dt><dd><p>Represents a term context - all terms are tied to a given context, and are discarded when the context ends. It is undefined behaviour to manipulate a term that has been freed, so make sure to extract any relevant terms to OCaml before the context is discarded.</p></dd></dl><dl><dt class="spec type" id="type-fn"><a href="#type-fn" class="anchor"></a><code><span class="keyword">type</span> fn</code></dt><dd><p><code>fn [@@deriving eq, ord]</code> represents function symbols.</p></dd></dl><dl><dt class="spec type" id="type-atom"><a href="#type-atom" class="anchor"></a><code><span class="keyword">type</span> atom</code></dt><dd><p>Represents atoms in prolog. This is an internal type that is primarily exposed for performance reasons - in particular, comparing whether two atoms <code>: atom</code> are equal will be faster than comparing if two terms <code>: t</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-atom"><a href="#val-atom" class="anchor"></a><code><span class="keyword">val</span> atom : string <span>&#45;&gt;</span> <a href="index.html#type-atom">atom</a></code></dt><dd><p><code>atom name</code> constructs an atom with characters <code>name</code>.</p><p><b>Note</b>: If you call this function before <a href="index.html#val-initialise"><code>initialise</code></a> you will segfault.</p></dd></dl><dl><dt class="spec type" id="type-module_"><a href="#type-module_" class="anchor"></a><code><span class="keyword">type</span> module_</code></dt><dd><p><code>module_ [@@deriving eq, ord]</code> represents SWI-prolog modules.</p></dd></dl><dl><dt class="spec value" id="val-module_"><a href="#val-module_" class="anchor"></a><code><span class="keyword">val</span> module_ : string <span>&#45;&gt;</span> <a href="index.html#type-module_">module_</a></code></dt><dd><p><code>module_ name</code> returns a reference to the module with name <code>name</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_solutions"><a href="#val-fold_solutions" class="anchor"></a><code><span class="keyword">val</span> fold_solutions : <span>(<span>[&gt; <span>`Exception of <a href="index.html#type-t">t</a></span> <span>| `Last</span> <span>| `Solution</span> ]</span> <span>&#45;&gt;</span> <span><span>[&lt; `Close <span>| `Cut</span> ]</span> option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-query">query</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>fold_solutions fn qid</code> is the most general combinator for consuming the output of Prolog queries. It calls <code>fn</code> once for each solution to the query (or exception raised by the query), and allows the function to terminate early by either <code>`Close</code>ing the query (dropping all bindings), or <code>`Cut</code>ting the query (and keeping the bindings introduced by the current result). The function returns a boolean representing whether there were any results or not.</p><p>For many cases you probably don't need the generality of this combinator, and can get away with using one of the simpler wrappers we provide (see below).</p></dd></dl><dl><dt class="spec value" id="val-iter_solutions"><a href="#val-iter_solutions" class="anchor"></a><code><span class="keyword">val</span> iter_solutions : <span>?&#8288;on_error:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-query">query</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>iter_solutions ?on_error qid fn</code> calls <code>fn</code> once for each solution returned by the query <code>qid</code>, and returns true if there were any solutions at all. <code>on_error</code> is called with any exception terms that are raised by the query (if any).</p></dd></dl><dl><dt class="spec value" id="val-first_solution"><a href="#val-first_solution" class="anchor"></a><code><span class="keyword">val</span> first_solution : <a href="index.html#type-query">query</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>first_solution qid</code> consumes the query <code>qid</code> and preserves the bindings from the first solution to the query. The function returns a boolean representing whether there were any solutions or not.</p><p><b>raises</b> Failure if the prolog query raises an exception.</p></dd></dl><dl><dt class="spec value" id="val-last_solution"><a href="#val-last_solution" class="anchor"></a><code><span class="keyword">val</span> last_solution : <a href="index.html#type-query">query</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>last_solution qid</code> consumes the query <code>qid</code> and preserves the bindings from the last solution to the query. The function returns a boolean representing whether there were any solutions or not.</p><p><b>raises</b> Failure if the prolog query raises an exception.</p></dd></dl><dl><dt class="spec value" id="val-call"><a href="#val-call" class="anchor"></a><code><span class="keyword">val</span> call : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>call ctx term</code> runs the query represented by <code>term</code>, preserving the bindings produced by the first solution if the query succeeds at all (does not check if the query succeeds at all).</p><p><b>raises</b> Failure if the prolog query raises an exception.</p></dd></dl><dl><dt class="spec module" id="module-Syntax"><a href="#module-Syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Syntax/index.html"><code>Syntax</code></a> module provides a useful set of combinators for constructing prolog terms using idiomatic OCaml syntax.</p></dd></dl><dl><dt class="spec value" id="val-with_ctx"><a href="#val-with_ctx" class="anchor"></a><code><span class="keyword">val</span> with_ctx : <span>(<a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_ctx fn</code> creates a new term context <code>ctx</code> and calls <code>fn</code> with that context.</p><p><b>Note</b>: Any terms created within the context will be dropped at the end of this function - it is undefined behaviour to try and escape prolog terms out of <code>fn</code>. (You have been warned, nasal demons at the ready).</p><p><b>Note</b>: If you call this function before <a href="index.html#val-initialise"><code>initialise</code></a> you will segfault.</p></dd></dl><dl><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-query">query</a></code></dt><dd><p><code>eval ctx term</code> send the prolog term <code>term</code> to the prolog engine and returns a handle to the query.</p></dd></dl><dl><dt class="spec value" id="val-encode_list"><a href="#val-encode_list" class="anchor"></a><code><span class="keyword">val</span> encode_list : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>encode_list ctx ls</code> returns a prolog term representing the list <code>ls</code>.</p></dd></dl><dl><dt class="spec value" id="val-encode_string"><a href="#val-encode_string" class="anchor"></a><code><span class="keyword">val</span> encode_string : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>encode_string ctx str</code> returns a prolog term representing the string <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-fresh"><a href="#val-fresh" class="anchor"></a><code><span class="keyword">val</span> fresh : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fresh ctx</code> creates a new prolog variable that lasts for the scope of <code>ctx</code>.</p></dd></dl><dl><dt class="spec value" id="val-extract_list"><a href="#val-extract_list" class="anchor"></a><code><span class="keyword">val</span> extract_list : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p><code>extract_list ctx t</code> extracts a list of prolog terms from <code>t</code>.</p><p><b>Note</b>: It is undefined behaviour to call this function on a term that is not a list. If in doubt, check the type of the term with <a href="index.html#val-typeof"><code>typeof</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-extract_atom"><a href="#val-extract_atom" class="anchor"></a><code><span class="keyword">val</span> extract_atom : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-atom">atom</a></code></dt><dd><p><code>extract_atom ctx t</code> extracts an atom from <code>t</code>.</p><p><b>Note</b>: It is undefined behaviour to call this function on a term that is not an atom. If in doubt, check the type of the term with <a href="index.html#val-typeof"><code>typeof</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-extract_bool"><a href="#val-extract_bool" class="anchor"></a><code><span class="keyword">val</span> extract_bool : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>extract_bool ctx t</code> extracts a bool from <code>t</code>.</p><p><b>Note</b>: It is undefined behaviour to call this function on a term that is not a bool. If in doubt, check the type of the term with <a href="index.html#val-typeof"><code>typeof</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-extract_int"><a href="#val-extract_int" class="anchor"></a><code><span class="keyword">val</span> extract_int : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>extract_int ctx t</code> extracts an int from <code>t</code>.</p><p><b>Note</b>: It is undefined behaviour to call this function on a term that is not an int. If in doubt, check the type of the term with <a href="index.html#val-typeof"><code>typeof</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-extract_float"><a href="#val-extract_float" class="anchor"></a><code><span class="keyword">val</span> extract_float : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>extract_float ctx t</code> extracts a float from <code>t</code>.</p><p><b>Note</b>: It is undefined behaviour to call this function on a term that is not a float. If in doubt, check the type of the term with <a href="index.html#val-typeof"><code>typeof</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-extract_string"><a href="#val-extract_string" class="anchor"></a><code><span class="keyword">val</span> extract_string : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>extract_string ctx t</code> extracts a string from <code>t</code>.</p><p><b>Note</b>: It is undefined behaviour to call this function on a term that is not a string. If in doubt, check the type of the term with <a href="index.html#val-typeof"><code>typeof</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-extract_functor"><a href="#val-extract_functor" class="anchor"></a><code><span class="keyword">val</span> extract_functor : <a href="index.html#type-ctx">ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-atom">atom</a> * <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p><code>extract_int ctx t</code> extracts a compound term or atom from <code>t</code>.</p><p><b>Note</b>: It is undefined behaviour to call this function on a term that is not a functor or atom. If in doubt, check the type of the term with <a href="index.html#val-typeof"><code>typeof</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-typeof"><a href="#val-typeof" class="anchor"></a><code><span class="keyword">val</span> typeof : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ty">ty</a></code></dt><dd><p><code>typeof t</code> returns the type of term t.</p><p><b>Note</b>: If you call this function before <a href="index.html#val-initialise"><code>initialise</code></a> you will segfault.</p></dd></dl><dl><dt class="spec value" id="val-load_source"><a href="#val-load_source" class="anchor"></a><code><span class="keyword">val</span> load_source : string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>load_source src</code> loads <code>src</code> as prolog source code (i.e not a file) into the prolog engine.</p><p><b>Note</b>: If you call this function before <a href="index.html#val-initialise"><code>initialise</code></a> you will segfault.</p></dd></dl></div></body></html>