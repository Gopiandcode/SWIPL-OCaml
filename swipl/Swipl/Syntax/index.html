<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Syntax (swipl.Swipl.Syntax)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">swipl</a> &#x00BB; <a href="../index.html">Swipl</a> &#x00BB; Syntax</nav><h1>Module <code>Swipl.Syntax</code></h1><p>The <a href="index.html"><code>Syntax</code></a> module provides a useful set of combinators for constructing prolog terms using idiomatic OCaml syntax.</p><p>As the operators in this module shadow common OCaml ones (<code>&amp;&amp;, ||</code>), typically you want to locally open this module:</p><pre><code class="ml">Swipl.Syntax.(app (&quot;consult&quot; /@ 1) [! file]) </code></pre></header><dl><dt class="spec value" id="val-(/@)"><a href="#val-(/@)" class="anchor"></a><code><span class="keyword">val</span> (/@) : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-fn">fn</a></code></dt><dd><p><code>fn /@ arity</code> mirrors the prolog syntax <code>pred/arity</code> and declares a prolog function named <code>fn</code> with arity <code>arity</code>.</p><p><b>Note</b>: If you call this function before <a href="../index.html#val-initialise"><code>initialise</code></a> you will segfault.</p></dd></dl><dl><dt class="spec value" id="val-(!)"><a href="#val-(!)" class="anchor"></a><code><span class="keyword">val</span> (!) : string <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a></code></dt><dd><p><code>! atom</code> creates a prolog term representing the atom <code>atom</code>.</p><p><b>Note</b>: If you call this function before <a href="../index.html#val-initialise"><code>initialise</code></a> you will segfault.</p></dd></dl><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val</span> app : <span>?&#8288;module_:<a href="../index.html#type-module_">module_</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-fn">fn</a> <span>&#45;&gt;</span> <span><a href="../index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a></code></dt><dd><p><code>app ?module_ fn args</code> creates a prolog term that represents the symbolic expression <code>module_:fn(args...)</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&amp;&amp;)"><a href="#val-(&amp;&amp;)" class="anchor"></a><code><span class="keyword">val</span> (&amp;&amp;) : <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a></code></dt><dd><p><code>t1 &amp;&amp; t2</code> creates a prolog term that represents the conjunction of two prolog queries - i.e the prolog expression <code>t1,t2</code>.</p></dd></dl><dl><dt class="spec value" id="val-(||)"><a href="#val-(||)" class="anchor"></a><code><span class="keyword">val</span> (||) : <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a></code></dt><dd><p><code>t1 || t2</code> creates a prolog term that represents the disjunction of two prolog queries - i.e the prolog expression <code>t1; t2</code>.</p></dd></dl></div></body></html>